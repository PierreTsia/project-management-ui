---
description: This rule governs TypeScript development practices across the entire project. It should be considered whenever: (1) Planning new TypeScript features or components, (2) Modifying existing TypeScript code, (3) Reviewing or fixing TypeScript-related bugs, (4) Making architectural decisions that involve TypeScript, (5) Creating new TypeScript files or refactoring existing ones. The rule ensures consistent type safety, modern TypeScript patterns, and maintainable code structure. It's particularly crucial when dealing with data models, API interfaces, state management, and component architecture. Apply this rule when discussing, planning, or implementing any TypeScript-related changes to maintain code quality and prevent common pitfalls.
globs: 
alwaysApply: false
---
# TypeScript Best Practices

## Critical Rules

- Use strict type checking with `"strict": true` in tsconfig.json
- ALWAYS use type aliases over interfaces for better type composition ðŸŽ¯
- NEVER use classes - prefer pure functions and composable types ðŸ§©
- Always define explicit return types for functions
- Use union types instead of enums for simple flag values
- Leverage discriminated unions for complex state management
- Never use `any` type - use `unknown` for truly unknown types
- Always handle null and undefined cases explicitly
- Implement error handling with custom error types (as type unions, not classes)
- Use type guards for runtime type checking
- Keep generics simple and well-constrained
- Use Pick, Omit, Partial and other utility types for type composition
- Document complex types and ALL public functions with JSDoc comments
- Prefer composition over inheritance through intersection types
- Use const assertions for literal types where applicable

## Examples

<example>
// Good - Using type alias with explicit types
type UserState = {
  id: string;
  name: string;
  email: string | null;
  preferences: string[];
};

// Good - Discriminated union with type guard
type RequestPending = {
  status: 'pending';
};

type RequestSuccess = {
  status: 'success';
  data: UserState;
};

type RequestError = {
  status: 'error';
  error: string;
};

type RequestState = RequestPending | RequestSuccess | RequestError;

const isSuccess = (state: RequestState): state is RequestSuccess => 
  state.status === 'success';

// Good - Generic with constraints and pure function
const getProperty = <T, K extends keyof T>(obj: T, key: K): T[K] => obj[key];

// Good - Error handling with type unions
type ValidationError = {
  type: 'validation';
  field: string;
  message: string;
};

type NetworkError = {
  type: 'network';
  code: number;
  message: string;
};

type AppError = ValidationError | NetworkError;

// Good - Composition over inheritance
type WithTimestamp = {
  timestamp: number;
};

type UserWithMeta = UserState & WithTimestamp;
</example>

<example type="invalid">
// Bad - Using interface
interface User {
  id: string;
  name: string;
}

// Bad - Using class
class UserService {
  private users: User[];
  
  constructor() {
    this.users = [];
  }
  
  addUser(user: User) {
    this.users.push(user);
  }
}

// Bad - Using any type
const processData = (data: any) => {
  return data.someProperty;
};

// Bad - Mutable state and no type safety
type MutableUser = {
  id: string;
  name: string;
};

const users: MutableUser[] = [];
users.push({ id: '1', name: 'John' }); // Mutable array
</example> 