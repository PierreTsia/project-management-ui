# Testing Guidelines

## Overview
This rule defines the testing standards and patterns for the project management application. Follow these guidelines to maintain consistency, readability, and robustness in our test suite.

## Test Structure

### File Organization
- Place tests in `src/__tests__/` directory
- Mirror the source file structure: `src/components/Button.tsx` → `src/__tests__/components/Button.test.tsx`
- Use `.test.tsx` extension for React component tests
- Use `.test.ts` extension for utility/hook tests

### Test File Structure
```typescript
// 1. Imports
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, vi, beforeEach, expect } from 'vitest';
import { TestAppWithRouting } from '../../test/TestAppWithRouting';
import { createMockUser, createMockTask } from '../../test/mock-factories';

// 2. Mock declarations
const mockUseHook = vi.fn();

// 3. Mock implementations
vi.mock('../../hooks/useHook', () => ({
  useHook: () => mockUseHook(),
}));

// 4. Test data
const mockData = createMockUser({ name: 'Test User' });

// 5. Main describe block
describe('ComponentName', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Setup default mocks
  });

  // 6. Nested describe blocks for different functionality areas
  describe('Feature Group', () => {
    it('should do x when y', async () => {
      // Test implementation
    });
  });
});
```

## Describe Block Organization

### Main Component/Page Tests
```typescript
describe('ComponentName', () => {
  // Main component tests
});
```

### Feature Grouping
Use nested describe blocks to group related functionality:
```typescript
describe('ComponentName', () => {
  describe('Data Loading & Display', () => {
    // Tests for loading states, data display, error handling
  });

  describe('User Interactions', () => {
    // Tests for clicks, form submissions, user events
  });

  describe('Form Validation', () => {
    // Tests for validation rules, error messages
  });

  describe('Modal/Dialog Behavior', () => {
    // Tests for modal opening, closing, form submission
  });
});
```

## Test Naming Convention

### Consistent Pattern
Use the pattern: `should [expected behavior] when [condition/action]`

```typescript
// ✅ Good examples
it('should render loading state when data is loading', () => {});
it('should display error message when API call fails', () => {});
it('should open modal when create button is clicked', () => {});
it('should validate required fields when form is submitted empty', () => {});
it('should disable submit button when form is invalid', () => {});
it('should clear form when cancel button is clicked', () => {});
it('should show success message when task is created', () => {});
it('should update task status when dropdown value changes', () => {});
it('should filter results when search input changes', () => {});
it('should navigate to details page when item is clicked', () => {});

// ❌ Avoid these patterns
it('renders correctly', () => {}); // Too vague
it('works', () => {}); // Not descriptive
it('handles click', () => {}); // Missing context
it('test form submission', () => {}); // Wrong format
```

## Mock Factories

### Always Use Typed Mock Factories
```typescript
// ✅ Use factory functions
const mockUser = createMockUser({ 
  name: 'Alice Admin',
  email: 'alice@example.com' 
});

const mockTask = createMockTask({
  title: 'Test Task',
  status: 'TODO',
  assignee: mockUser
});

// ✅ Use factory arrays for multiple items
const mockTasks = createMockArray(mockTask, 3, [
  { title: 'Task 1' },
  { title: 'Task 2' },
  { title: 'Task 3' }
]);

// ❌ Avoid manual object creation
const mockUser = {
  id: 'user-1',
  name: 'Test User',
  email: 'test@example.com',
  // ... many more properties
};
```

### Mock Hook Patterns
```typescript
// Declare mock functions at the top
const mockUseHook = vi.fn();

// Mock the hook module
vi.mock('../../hooks/useHook', () => ({
  useHook: () => mockUseHook(),
}));

// Setup default return values in beforeEach
beforeEach(() => {
  mockUseHook.mockReturnValue({
    data: undefined,
    isLoading: true,
    error: null,
  });
});

// Override in specific tests
it('should display data when loaded', () => {
  mockUseHook.mockReturnValue({
    data: mockData,
    isLoading: false,
    error: null,
  });
  // Test implementation
});
```

## Selector Strategy

### Prefer Data Test IDs
```typescript
// ✅ Use data-testid for robust selectors
expect(screen.getByTestId('create-task-modal')).toBeInTheDocument();
await user.click(screen.getByTestId('submit-button'));
expect(screen.getByTestId('error-message')).toHaveTextContent('Required field');

// ✅ Use role-based selectors when appropriate
expect(screen.getByRole('button', { name: /create task/i })).toBeInTheDocument();
expect(screen.getByRole('dialog')).toBeInTheDocument();

// ✅ Use label-based selectors for form fields
await user.type(screen.getByLabelText(/task title/i), 'New Task');

// ❌ Avoid fragile selectors
expect(screen.getByText('Create Task')).toBeInTheDocument(); // Can break with text changes
expect(screen.getByClassName('btn-primary')).toBeInTheDocument(); // Can break with styling changes
```

### Adding Data Test IDs
When writing tests, add data-testid attributes to components for robust testing:
```typescript
// In component
<Button data-testid="create-task-button">Create Task</Button>
<Dialog data-testid="create-task-modal">...</Dialog>

// In test
await user.click(screen.getByTestId('create-task-button'));
expect(screen.getByTestId('create-task-modal')).toBeInTheDocument();
```

## Test Implementation Patterns

### Async Operations
```typescript
it('should create task when form is submitted', async () => {
  const user = userEvent.setup();
  const mockCreateTask = vi.fn().mockResolvedValue({ id: 'new-task' });
  
  mockUseCreateTask.mockReturnValue({
    mutateAsync: mockCreateTask,
    isPending: false,
  });

  render(<TestAppWithRouting url="/tasks" />);
  
  // Fill form
  await user.type(screen.getByTestId('task-title-input'), 'New Task');
  await user.click(screen.getByTestId('submit-button'));

  // Assert async behavior
  await waitFor(() => {
    expect(mockCreateTask).toHaveBeenCalledWith({
      title: 'New Task',
      // ... other expected data
    });
  });
});
```

### Error Handling
```typescript
it('should display error when API call fails', async () => {
  const mockError = new Error('API Error');
  mockUseCreateTask.mockReturnValue({
    mutateAsync: vi.fn().mockRejectedValue(mockError),
    isPending: false,
  });

  render(<TestAppWithRouting url="/tasks" />);
  
  await user.click(screen.getByTestId('submit-button'));

  await waitFor(() => {
    expect(screen.getByText(/error occurred/i)).toBeInTheDocument();
  });
});
```

### Form Validation
```typescript
it('should show validation errors when required fields are empty', async () => {
  const user = userEvent.setup();
  render(<TestAppWithRouting url="/tasks" />);
  
  // Submit form without filling required fields
  await user.click(screen.getByTestId('submit-button'));

  expect(screen.getByText(/title is required/i)).toBeInTheDocument();
  expect(screen.getByText(/project is required/i)).toBeInTheDocument();
});
```

## Comments Guidelines

### Minimal Comments
```typescript
// ✅ Only comment when necessary for clarity
it('should clear assignee when project changes in global mode', () => {
  // This test verifies the useEffect dependency behavior
  // when showProjectSelector changes from false to true
});

// ✅ Comment complex setup
it('should handle multiple contributors with different roles', () => {
  // Setup: Owner, Admin, and Read users
  const owner = createMockUser({ id: 'owner-1', name: 'Owner' });
  const admin = createMockUser({ id: 'admin-1', name: 'Admin' });
  const reader = createMockUser({ id: 'reader-1', name: 'Reader' });
  
  // Test implementation...
});

// ❌ Avoid obvious comments
it('should render component', () => {
  // Render the component <- Obvious, don't comment
  render(<Component />);
  
  // Check if it renders <- Obvious, don't comment
  expect(screen.getByTestId('component')).toBeInTheDocument();
});
```

## Best Practices

### 1. Test Setup
- Always use `beforeEach` to reset mocks and setup defaults
- Use `vi.clearAllMocks()` to ensure clean state between tests
- Clear localStorage when testing components that use it

### 2. User Interactions
- Always use `userEvent.setup()` for user interactions
- Use `waitFor` for async operations
- Test the complete user flow, not just individual actions

### 3. Assertions
- Be specific in assertions: `toHaveTextContent` vs `toBeInTheDocument`
- Test both positive and negative cases
- Verify the correct data is passed to functions

### 4. Mock Management
- Mock at the module level, not individual functions
- Use `vi.importActual` to preserve other exports
- Override mocks in individual tests when needed

### 5. Test Data
- Use factory functions for consistent test data
- Create realistic test scenarios
- Test edge cases and error conditions

## Examples from Codebase

### Good Test Structure
```typescript
describe('CreateTaskModal', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockUseProjects.mockReturnValue({
      data: { projects: [mockProject] },
      isLoading: false,
    });
  });

  describe('Modal Behavior', () => {
    it('should open modal when create button is clicked', async () => {
      const user = userEvent.setup();
      render(<TestAppWithRouting url="/tasks" />);
      
      await user.click(screen.getByRole('button', { name: /create task/i }));
      
      expect(screen.getByTestId('create-task-modal')).toBeInTheDocument();
    });

    it('should close modal when cancel button is clicked', async () => {
      const user = userEvent.setup();
      render(<TestAppWithRouting url="/tasks" />);
      
      await user.click(screen.getByRole('button', { name: /create task/i }));
      await user.click(screen.getByTestId('cancel-button'));
      
      expect(screen.queryByTestId('create-task-modal')).not.toBeInTheDocument();
    });
  });

  describe('Form Validation', () => {
    it('should show validation errors when required fields are empty', async () => {
      const user = userEvent.setup();
      render(<TestAppWithRouting url="/tasks" />);
      
      await user.click(screen.getByRole('button', { name: /create task/i }));
      await user.click(screen.getByTestId('create-task-button'));
      
      expect(screen.getByText(/title is required/i)).toBeInTheDocument();
    });
  });
});
```

This rule ensures consistent, maintainable, and robust tests across the entire codebase.